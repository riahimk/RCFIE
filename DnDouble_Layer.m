classdef DnDouble_Layer < Integral_Operator
    %properties (SetAccess=private,GetAccess=public)
    %    K1;
    %    K2;
    %end
    methods
        function dnDL=DnDouble_Layer(shape,pb)
            dnDL=dnDL@Integral_Operator(shape);
            set_T(dnDL);
            set_Kernel(dnDL,shape,pb);
        end
        function set_Kernel(dnDL,shape,ScParam)
            n = dnDL.n;
            t = discretize(n);
            bess_h_0 = besselh(0, ScParam.k * (shape.distance + eye(2*n)));
            bess_h_1 = besselh(1, ScParam.k * (shape.distance + eye(2*n)));
            
            for i =1:(2*n)
                for j =1:(2*n)
                    if (shape.distance(i,j)) < 1.e-09
                        dnDL.K1(i,j) = -ScParam.k^2/4/pi*shape.arclength(i)^2;
                        dnDL.K2(i,j) = (pi*1i-1-2*dnDL.gamma-2*log(ScParam.k * shape.arclength(i)/2 )) ...
                           *( ScParam.k^2 /4/pi * shape.arclength(i)^2 ) + 1/12/pi ...
                           +dot([shape.x_t(i);shape.y_t(i)],[shape.x_tt(i);shape.y_tt(i)])^2/(2*pi*shape.arclength(i)^4)...
                           -dot([shape.x_tt(i);shape.y_tt(i)],[shape.x_tt(i);shape.y_tt(i)])/(4*pi*shape.arclength(i)^2)...
                           -dot([shape.x_t(i);shape.y_t(i)],[shape.x_ttt(i);shape.y_ttt(i)])/(6*pi*shape.arclength(i)^2);
                    else
                        dnDL.K1(i,j) = -1/2/pi ...
                            * dot([shape.x_t(i);shape.y_t(i)],[shape.x(i)-shape.x(j),shape.y(i)-shape.y(j)]) ...
                            * dot([shape.x_t(j);shape.y_t(j)],[shape.x(i)-shape.x(j),shape.y(i)-shape.y(j)]) ...
                            /shape.distance(i,j)^2 ...
                            * (ScParam.k^2 * real(bess_h_0(i,j)) - 2*ScParam.k * real(bess_h_1(i,j))/shape.distance(i,j)) ...
                            - ScParam.k * dot([shape.x_t(i);shape.y_t(i)],[shape.x_t(j);shape.y_t(j)]) ...
                            / 2/ pi/shape.distance(i,j) * real(bess_h_1(i,j));

                        dnDL.K2(i,j) = 1i/2 ...
                            * dot([shape.x_t(i);shape.y_t(i)],[shape.x(i)-shape.x(j),shape.y(i)-shape.y(j)]) ...
                            * dot([shape.x_t(j);shape.y_t(j)],[shape.x(i)-shape.x(j),shape.y(i)-shape.y(j)]) ...
                            /shape.distance(i,j)^2 ...
                            * ( ScParam.k^2 * bess_h_0(i,j) - 2*ScParam.k*bess_h_1(i,j)/shape.distance(i,j) ) ...
                            + 1i*ScParam.k * dot([shape.x_t(i);shape.y_t(i)],[shape.x_t(j);shape.y_t(j)]) ...
                            / 2 /shape.distance(i,j) * bess_h_1(i,j) ...
                            + 1/4/pi/sin(.5*t(i)-.5*t(j))^2 ...
                            - dnDL.K1(i,j)* log(4*sin(t(i)/2-t(j)/2 )^2  );
                    end % end if diag
                    %fprintf('dn_DL_1(%d,%d)=%f\n',i,j,dnDL.K1(i,j));
                    %fprintf('dn_DL_2(%d,%d)=%f\n',i,j,dnDL.K2(i,j));
                end % for loop(j)
            end % for loop(i)
        %N1 = dnDL.K1
        %N2 = dnDL.K2
        end % constructor
    end % methods 
end 